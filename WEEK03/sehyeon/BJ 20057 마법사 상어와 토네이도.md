### 문제 설명

https://www.acmicpc.net/problem/20057

토네이도가 격자 가운데에서 시작하여 뱅글뱅글 도는 동안 격자 밖으로 날아가는 모래의 수를 세는 문제
<br>
### 풀이 방식

```
시작점 설정, 시작 방향은 왼쪽
토네이도가 돌아가는 방향 확인하면서
벗어난 모래 확인용 변수 필요
while문으로 반복
	방향의 왼쪽이 아직 방문하지 않은 노드면 돌고 아니면 직진(토네이도 위치, 방향 바꾸기) -> 아 근데 처음 위치에서는 직진
	토네이도 위치의 모래 저장(변수 필요)
	for v[0~9] 모래 인덱스가 벗어나는지 확인
		벗어나면 벗어난거에 추가, 현위치에서 감하기
		아니라면 sand에 모래 값 계산해서 추가, 현위치에서 감하기
	남아있는 모래 양 v[10] 위치에 더하기
	현위치 (1,1)이면 중단
```

<details>
  <summary><h3>전체 코드</h3></summary>

```cpp
#include<iostream>
#include<vector>

using namespace std;

int sand[500][500];
bool isvisit[500][500];

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	//위(dir0)를 바라보며 날리는 기준 y, x
	//왼쪽(dir1)은 x, y
	//오른쪽(dir3)은 x, -y
	//아래(dir2)는 -y, x
	pair<int, int> v[10] = { {-2, 0}, { -1,1 }, { 0,1 }, { 0,2 }, { 1,1 }, { -1,-1 }, { 0,-1 }, { 0,-2 }, { 1,-1 }, { -1,0 } };
	int ratio[9] = { 5, 10, 7, 2, 1, 10, 7, 2, 1 };

	//모래 양 입력
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> sand[i][j];
		}
	}
	//시작점 설정, 시작 방향은 왼쪽
	int r = n / 2, c = n / 2;
	int dir = 1;
	
	int sand_out = 0;
	isvisit[n / 2][n / 2] = 1;
	while (!(r == 0 && c == 0)) {
		//시작점에서는 한 칸 왼쪽으로
		if (r == n / 2 && c == n / 2) c--;
		else {
			if (dir == 0) {
				//위쪽 보고 있을 때, 왼쪽이 안 간 곳이라면 turn, 한 칸 이동
				if (!isvisit[r][c - 1]) {
					dir = 1;
					c--;
				}
				else r--;
			}
			else if (dir == 1) {
				if (!isvisit[r + 1][c]) {
					dir = 2;
					r++;
				}
				else c--;
			}
			else if (dir == 2) {
				if (!isvisit[r][c + 1]) {
					dir = 3;
					c++;
				}
				else r++;
			}
			else if (dir == 3) {
				if (!isvisit[r - 1][c]) {
					dir = 0;
					r--;
				}
				else c++;
			}
		}
		isvisit[r][c] = 1;
		//모래 계산
		//현재 모래
		int tmp = sand[r][c];
		for (int i = 0; i < 10; i++) {
			//모래가 떨어질 위치 선정
			int dr, dc;
			if (dir == 0) {
				dr = v[i].first;
				dc = v[i].second;
			}
			else if (dir == 1) {
				dr = v[i].second;
				dc = v[i].first;
			}
			else if (dir == 2) {
				dr = -v[i].first;
				dc = v[i].second;
			}
			else {
				dr = v[i].second;
				dc = -v[i].first;
			}
			//떨어질 모래의 양 계산
			int r2 = r + dr, c2 = c + dc;
			int fly_sand = tmp * ratio[i] / 100;
			if (i == 9) fly_sand = sand[r][c];//남은 양은 한칸 앞으로
			//격자 밖으로 나가는 경우, 아닌 경우 모래 양 더하고 빼기
			if (r2 < 0 || r2 >= n || c2 < 0 || c2 >= n) {
				sand_out += fly_sand;
			}
			else sand[r2][c2] += fly_sand;
			sand[r][c] -= fly_sand;
		}
	}
	cout << sand_out;
}

```
</details>

### 코드 세부 설명

- 초기 모래의 양을 입력받을 sand 배열, 토네이도가 지나갔는지 확인할 isvisit 배열

```cpp
int sand[500][500];
bool isvisit[500][500];
```
<br>

- 위를 바라볼 때를 기준으로 모래가 떨어질 거리와 비율을 배열에 저장
    
    (방향은 반시계방향으로 dir 0 1 2 3)
    

```cpp
pair<int, int> v[10] = { {-2, 0}, { -1,1 }, { 0,1 }, { 0,2 }, { 1,1 }, { -1,-1 }, { 0,-1 }, { 0,-2 }, { 1,-1 }, { -1,0 } };
int ratio[9] = { 5, 10, 7, 2, 1, 10, 7, 2, 1 };
```
<br>

- 입력 및 초기 변수 설정

```cpp
int n;
cin >> n;
for (int i = 0; i < n; i++) {
	for (int j = 0; j < n; j++) {
		cin >> sand[i][j];
	}
}
//시작점 설정, 시작 방향은 왼쪽
int r = n / 2, c = n / 2;
int dir = 1;

int sand_out = 0;
isvisit[n / 2][n / 2] = 1;
```
<br>

- 반복(1) 토네이도 움직이기

```cpp
if (dir == 0) {
	//위쪽 보고 있을 때, 왼쪽이 안 간 곳이라면 turn, 한 칸 이동
	if (!isvisit[r][c - 1]) {
		dir = 1;
		c--;
	}
	else r--;
}
```
<br>

- 반복(2) 방문처리 및 해당 위치 모래량 저장 ← 소수점은 버리는 조건 때문에 해당 위치에서 바로 빼면 오차값이 생길 것이라 판단함

```cpp
isvisit[r][c] = 1;
int tmp = sand[r][c];
```
<br>

- 반복(3) 모래가 떨어질 위치 구하기

```cpp
int dr, dc;
if (dir == 0) {
	dr = v[i].first;
	dc = v[i].second;
}
int r2 = r + dr, c2 = c + dc;
```
<br>

- 반복(4) 떨어질 모래의 양 계산 후 각 칸의 값 수정
    
    만약 격자 밖으로 나간다면 sand_out 추가
    
    ɑ에 들어갈 값 == 주변에 날아가고 토네이도 위치에 남아있는 값
    

```cpp
int fly_sand = tmp * ratio[i] / 100;
if (i == 9) fly_sand = sand[r][c];//남은 양은 한칸 앞으로
//격자 밖으로 나가는 경우, 아닌 경우 모래 양 더하고 빼기
if (r2 < 0 || r2 >= n || c2 < 0 || c2 >= n) {
	sand_out += fly_sand;
}
else sand[r2][c2] += fly_sand;
sand[r][c] -= fly_sand;
```
<br>

- 토네이도 위치가 (0,0)(문제에서는 1,1)에 도달하면 sand_out 출력 후 종료
<br>

### 느낀 점

로직이 꽤나 길어지는데, 중간에 값을 한번 확인해야겠다는 쎄한 느낌이 들었음.

모래 계산 하는 부분 작성하다가 주석처리하고 토네이도가 지나가는 방향만 우선 확인해 봤는데,

워메 아니나 다를까 처음 이동을 잘못하고 있어서 나중에 멘붕왔겠다 싶음 ㅎ

중간중간 확인한 나 자신 칭찬해

### 문제 설명

https://www.acmicpc.net/problem/2251

용량 a, b, c를 가진 물병 3개가 있고, 초기 물의 양은 각각 0, 0, c

물병의 물을 옮기면서(다 옮기거나 꽉 차거나) A물병이 비어있을 때 C에 담겨 있을 수 있는 물의 모든 양을 오름차순으로 구하는 문제

</br>

### 풀이 방식

BFS + 구현으로 접근.

세 물병에서 각각 다른 물병으로 옮기고, 그 상태에서의 A와 C를 확인

</br>

### 전체 코드

```cpp
#include<iostream>
#include<set>
#include<queue>

using namespace std;

int a, b, c;
bool isvisit[201][201][201];
set<int> ans;

struct water {
	int x, y, z;
};

void bfs() {
	queue<water> q;
	isvisit[0][0][c] = 1;
	ans.insert(c);
	q.push({ 0,0,c });
	while (!q.empty()) {
		water tmp = q.front();
		q.pop();
		int tx = tmp.x;
		int ty = tmp.y;
		int tz = tmp.z;
		//a가 0이 아니고 옮길 수 있으면 옮기기
		if (tx != 0) {
			//a->b
			if (tx + ty <= b && !isvisit[0][tx + ty][tz]) {
				q.push({ 0,tx + ty,tz });
				isvisit[0][tx + ty][tz] = 1;
				ans.insert(tz);
			}
			else if (tx + ty > b && !isvisit[tx + ty - b][b][tz]) {
				q.push({ tx + ty - b, b, tz });
				isvisit[tx + ty - b][b][tz] = 1;
			}
			//a->c
			if (tx + tz <= c && !isvisit[0][ty][tx+tz]) {
				q.push({ 0,ty,tx + tz });
				isvisit[0][ty][tx + tz] = 1;
				ans.insert(tx+tz);
			}
			else if (tx + tz > c && !isvisit[tx + tz - c][ty][c]) {
				q.push({ tx + tz - c, ty, c });
				isvisit[tx + tz - c][ty][c] = 1;
			}
		}
		//b
		if (ty != 0) {
			//b->a
			if (tx + ty <= a && !isvisit[tx + ty][0][tz]) {
				q.push({ tx + ty,0,tz });
				isvisit[tx + ty][0][tz] = 1;
			}
			else if (tx + ty > a && !isvisit[a][tx + ty - a][tz]) {
				q.push({ a,tx + ty - a, tz });
				isvisit[a][tx + ty - a][tz] = 1;
			}
			//b->c
			if (ty + tz <= c && !isvisit[tx][0][ty + tz]) {
				q.push({ tx,0,ty + tz });
				isvisit[tx][0][ty + tz] = 1;
				if (tx == 0) ans.insert(ty + tz);
			}
			else if (ty + tz > c && !isvisit[tx][ty + tz - c][c]) {
				q.push({ tx,ty + tz - c, c });
				isvisit[tx][tx + tz - c][c] = 1;
				if (tx == 0) ans.insert(c);
			}
		}
		//c
		if (tz != 0) {
			//c->a
			if (tx + tz <= a && !isvisit[tx + tz][ty][0]) {
				q.push({ tx + tz,ty,0 });
				isvisit[tx + tz][ty][0] = 1;
			}
			else if (tx + tz > a && !isvisit[a][ty][tx + tz - a]) {
				q.push({ a,ty,tx + tz - a });
				isvisit[a][ty][tx+tz-a] = 1;
			}
			//c->b
			if (ty + tz <= b && !isvisit[tx][ty + tz][0]) {
				q.push({ tx,ty + tz,0 });
				isvisit[tx][ty + tz][0] = 1;
				if (tx == 0) ans.insert(0);
			}
			else if (ty + tz > b && !isvisit[tx][b][ty + tz - b]) {
				q.push({ tx,b,ty + tz - b });
				isvisit[tx][b][tx + tz - b] = 1;
				if (tx == 0) ans.insert(tx + tz - b);
			}
		}
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> a >> b >> c;
	bfs();
	for (auto it = ans.begin(); it != ans.end(); it++) cout << *it << " ";
}
```
</br>

### 코드 세부 설명

- 물병 3개에 담긴 물의 양을 water라는 구조체로 저장
- set은 C에 담긴 물의 양을 담는 집합

```cpp
int a, b, c;
bool isvisit[201][201][201];
set<int> ans;

struct water {
	int x, y, z;
};
```
</br>

- 전부 다 옮겨 담을 수 있는 경우, 받는 물병이 꽉 차는 경우 나눠서 구현

```cpp
//a->b
			if (tx + ty <= b && !isvisit[0][tx + ty][tz]) {
				q.push({ 0,tx + ty,tz });
				isvisit[0][tx + ty][tz] = 1;
				ans.insert(tz);
			}
			else if (tx + ty > b && !isvisit[tx + ty - b][b][tz]) {
				q.push({ tx + ty - b, b, tz });
				isvisit[tx + ty - b][b][tz] = 1;
			}
```
</br>

### 놓칠 뻔한 점

- A→B, A→C로 옮기는 경우에만 A==0인지 확인했었는데,
B→C, C→B인 경우에도 확인해야 했음!(테스트 예제 돌려보고 깨달음)

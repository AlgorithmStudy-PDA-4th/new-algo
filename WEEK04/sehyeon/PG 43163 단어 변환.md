### 문제 설명

https://school.programmers.co.kr/learn/courses/30/lessons/43163

</br>

### 풀이 방식

“가장 짧은 변환 과정” → BFS?

그때그때 비교하기? ⇒ 와 시간 꽤나 오래 걸릴듯..?

한번만 비교해서 저장해 놓고 시작하자 ~

```
1. 각 단어별로 다른 단어로 갈 수 있는 단어들을 확인해서 이차원 벡터에 저장
(갈 수 있는 노드 표현하는 느낌)

2. BFS 돌면서 확인
```
</br>

### 전체 코드

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

vector<int> can_go[50];
queue<pair<int, int>> q;
bool isvisit[50];

//두 단어 비교 후 알파벳 차이가 하나인지 반환
bool check_two(string a, string b) {
    bool flag = 0;
    for(int i=0;i<a.size();i++) {
        if(a[i]!=b[i]) {
            if(flag) return 0;
            else flag = 1;
        }
    }
    if(flag) return 1;
    else return 0;
}

//각 단어끼리 한번에 변환할 수 있는지 확인하여 가능 여부 저장
void words_check(vector<string>* words) {
    vector<string> words2 = *words;
    for(int i=0;i<words2.size()-1;i++) {
        for(int j=i+1;j<words2.size();j++) {
            if(check_two(words2[i], words2[j])) {
                can_go[i].push_back(j);
                can_go[j].push_back(i);
            }
        }
    }
}

//제시어와 한 글자만 다른 단어 확인
bool check_begin(string* begin, string* target, vector<string>* words) {
    vector<string> words2 = *words;
    for(int i=0;i<words2.size();i++) {
        if(check_two(*begin, words2[i])) {
            if(words2[i]==*target) return 1;
            q.push({i,1});
            isvisit[i] = 1;
        }
    }
    return 0;
}

int bfs(vector<string>* words, string* target) {
    vector<string> words2 = *words;
    while(!q.empty()) {
        pair<int, int> tmp = q.front();
        q.pop();
        for(int i=0;i<can_go[tmp.first].size();i++) {
            if(words2[can_go[tmp.first][i]]==*target) return tmp.second+1;
            if(!isvisit[can_go[tmp.first][i]]) {
                isvisit[can_go[tmp.first][i]]= 1;
                q.push({can_go[tmp.first][i], tmp.second+1});
            }
        }
    }
    return 0;
}

int solution(string begin, string target, vector<string> words) {
    
    words_check(&words);
    if(check_begin(&begin, &target, &words)) return 1;
    return bfs(&words, &target);
    
}
```

</br>

### 코드 세부 설명

- 단어들끼리 변환 가능한 경우를 벡터 배열에 저장하고, 각 진행 과정을 큐, 방문 배열을 이용하여 저장

```cpp
vector<int> can_go[50];
queue<pair<int, int>> q;
bool isvisit[50];
```
</br>

- 두 단어 비교하기
- 다른 알파벳이 처음 나오면 flag=1, 두번째 나오면 return 0

```cpp
bool check_two(string a, string b) {
    bool flag = 0;
    for(int i=0;i<a.size();i++) {
        if(a[i]!=b[i]) {
            if(flag) return 0;
            else flag = 1;
        }
    }
    if(flag) return 1;
    else return 0;
}
```
</br>

- words 내 변환 가능한 경우 확인

```cpp
void words_check(vector<string>* words) {
    vector<string> words2 = *words;
    for(int i=0;i<words2.size()-1;i++) {
        for(int j=i+1;j<words2.size();j++) {
            if(check_two(words2[i], words2[j])) {
                can_go[i].push_back(j);
                can_go[j].push_back(i);
            }
        }
    }
}
```
</br>

- 제시어와 한 글자만 다른 단어 확인

```cpp
bool check_begin(string* begin, string* target, vector<string>* words) {
    vector<string> words2 = *words;
    for(int i=0;i<words2.size();i++) {
        if(check_two(*begin, words2[i])) {
            if(words2[i]==*target) return 1;
            q.push({i,1});
            isvisit[i] = 1;
        }
    }
    return 0;
}
```
</br>

- BFS 돌면서 탐색

```cpp
int bfs(vector<string>* words, string* target) {
    vector<string> words2 = *words;
    while(!q.empty()) {
        pair<int, int> tmp = q.front();
        q.pop();
        for(int i=0;i<can_go[tmp.first].size();i++) {
            if(words2[can_go[tmp.first][i]]==*target) return tmp.second+1;
            if(!isvisit[can_go[tmp.first][i]]) {
                isvisit[can_go[tmp.first][i]]= 1;
                q.push({can_go[tmp.first][i], tmp.second+1});
            }
        }
    }
    return 0;
}
```
</br>

### 느낀 점

- 메소드에 변수를 값으로 안 넘기고 배열로 넘겨보려다 포인터의 늪에 빠져..😭😭
- 로직별로 모듈화 해보고 싶다는 생각이 들어서, 문제 푸는 시간에 상관없이 작성해 봤는데..생각보다 꼬여서 당황했다(익숙해지자!)
